<!-- ===================== index.html (clean) ===================== -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Search + Measure</title>

  <!-- Tiny transparent favicon so the browser stops requesting /favicon.ico -->
  <link rel="icon" href="data:image/png;base64,iVBORw0KGgo=">

  <!-- Your stylesheet (optional; page will still work without it) -->
  <link rel="stylesheet" href="css/styles.css" />

  <style>
    :root{--gap:24px;--green:#22c55e;--green-dark:#16a34a;--border:#e5e7eb;--text:#0f172a;--bg:#f8fafc;--white:#fff;--shadow:0 8px 24px rgba(0,0,0,.08);--radius:16px}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text)}
    .page{max-width:1400px;margin:40px auto;padding:0 20px;display:grid;grid-template-columns:1fr 1.5fr;gap:var(--gap)}
    @media (max-width:900px){.page{grid-template-columns:1fr}}
    .card{background:var(--white);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:20px}
    .search-box{position:relative;display:flex;align-items:center;gap:10px;border:2px solid #1f2937;border-radius:999px;padding:10px 14px;background:#e5e7eb}
    .search-box input[type="search"]{flex:1;border:none;outline:none;font-size:16px;background:transparent;color:#111827}
    .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    label{font-size:13px;color:#64748b;display:block;margin-bottom:6px}
    input[type=text],input[type=email],input[type=tel],input[type=number],select{width:100%;padding:12px;border:1px solid var(--border);border-radius:10px;font-size:15px;background:var(--white)}
    .checkbox-row{display:flex;align-items:center;gap:10px;margin-top:8px}
    .checkbox-row input[type=checkbox]{width:18px;height:18px}
    .half-inch-gap{margin-top:0.5in}
    .pair{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .btn{width:100%;padding:14px 16px;border:0;border-radius:12px;font-weight:600;font-size:16px;cursor:pointer}
    .btn-primary{background:var(--green);color:#fff}.btn-primary:hover{background:var(--green-dark)}
    .btn-secondary{background:var(--green);color:#fff}.btn-secondary:hover{background:var(--green-dark)}
    .map-card{position:relative;min-height:520px;display:flex;gap:10px}
    .map-box{position:relative;flex:1;height:100%;min-height:520px;border:1px solid var(--border);border-radius:14px;overflow:hidden}
    #map{position:absolute;inset:0}
    #mapCaption{position:absolute;left:12px;bottom:12px;background:rgba(255,255,255,.85);padding:6px 10px;border-radius:10px;font-size:13px;color:#334155}
    .pac-container{z-index:10000}
    .tools{width:84px;flex-shrink:0;border:1px solid var(--border);border-radius:14px;background:#f9f9f9;display:flex;flex-direction:column;gap:10px;padding:10px;box-shadow:var(--shadow);height:fit-content}
    .tools button{width:100%;padding:10px 8px;font-size:13px;background:#fff;border:1px solid #ccc;border-radius:8px;cursor:pointer}
    .tools button:hover{background:#eee}
    .tools .btn-green{background:var(--green);color:#fff;border:1px solid var(--green-dark)}
    .tools .btn-green:hover{background:var(--green-dark)}
  </style>
</head>
<body>
<main class="page">
  <section class="card" aria-label="Search and contact">
    <div class="search-box">
      <input id="address" name="address" type="search" placeholder="Search address..." autocomplete="off" required aria-label="Search for an address" />
    </div>

    <form id="contactForm" novalidate>
      <div class="grid-2" style="margin-top:12px;">
        <div>
          <label for="firstName">First Name</label>
          <input id="firstName" name="firstName" type="text" required autocomplete="given-name">
        </div>
        <div>
          <label for="lastName">Last Name</label>
          <input id="lastName" name="lastName" type="text" required autocomplete="family-name">
        </div>
      </div>

      <div class="grid-2" style="margin-top:12px;">
        <div>
          <label for="phone">Phone</label>
          <input id="phone" name="phone" type="tel" inputmode="tel" required autocomplete="tel">
        </div>
        <div>
          <label for="email">Email</label>
          <input id="email" name="email" type="email" required autocomplete="email">
        </div>
      </div>

      <div style="margin-top:12px;">
        <label for="referrer">How did you find us?</label>
        <select id="referrer" name="referrer" required>
          <option value="" disabled selected>Select one...</option>
          <option>Google</option>
          <option>Friend</option>
          <option>Social Media</option>
          <option>Yard Sign / Vehicle</option>
          <option>Other</option>
        </select>
      </div>

      <div class="checkbox-row">
        <input id="smsConsent" name="smsConsent" type="checkbox" required>
        <label for="smsConsent">Permission to contact you on this phone number</label>
      </div>

      <div class="half-inch-gap pair">
        <div>
          <label for="lotSqft">Lot sq ft</label>
          <input id="lotSqft" name="lotSqft" type="number" min="0" step="1">
        </div>
        <div>
          <label for="turfSqft">Turf sq ft</label>
          <input id="turfSqft" name="turfSqft" type="number" min="0" step="1">
        </div>
      </div>

      <div class="half-inch-gap"><button id="measureBtn" type="button" class="btn btn-primary">Measure Now</button></div>
      <div class="half-inch-gap"><button id="continueBtn" type="submit" class="btn btn-secondary">Continue</button></div>
    </form>
  </section>

  <section class="card map-card" aria-label="Map">
    <div class="map-box" id="mapBox">
      <div id="map"></div>
      <div id="mapCaption">Type an address and press Enter</div>
    </div>

    <!-- Tools -->
    <nav class="tools" aria-label="Map tools">
      <button id="btnManualTurf">Manual Turf Measure</button>
      <button id="btnOutlineLot">Outline Property Boundaries</button>
      <button id="btnEdit">Edit</button>
      <button id="btnDelete">Delete</button>
      <button id="btnReset">Reset</button>
      <button id="btnUndo">Undo</button>
      <button id="btnRedo">Redo</button>
      <button id="btnSave">Save</button>
      <button id="btnSearchAgain" class="btn-green" title="Start a new search">Search Again</button>
    </nav>
  </section>
</main>

<!-- Your app code (must load before Google callback fires) -->
<script src="js/map.js?v=8"></script>

<!-- Google Maps (paste your real key where it says YOUR_KEY) -->
<script
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDjk7r8xx7DX7MZRwdSVAk7C5CwleF0OWY&libraries=places,drawing,geometry&callback=initMap&loading=async"
  async defer></script>
</body>
</html>


<!-- ===================== js/map.js (complete) ===================== -->
<script type="text/plain" data-filename="js/map.js">
// js/map.js

// Optional: set this after you deploy your Vercel API (e.g., "https://parcel-api-yourname.vercel.app")
const API_BASE_URL = ""; // leave empty for now

// Globals
let map, drawManager;
let lotPolygon = null;
const turfPolygons = [];

// Google calls this via callback=initMap in the loader tag
window.initMap = function initMap() {
  map = new google.maps.Map(document.getElementById("map"), {
    center: { lat: 39.8283, lng: -98.5795 },
    zoom: 4,
    mapTypeId: "roadmap",
    tilt: 0,
    heading: 0,
  });

  keepOverhead();
  lockOverhead();

  setupAutocomplete();
  setupDrawingTools();
  say("Type an address and press Enter, or use the tools on the right.");
};

// ---------------- Autocomplete (new → legacy → Enter) ----------------
async function setupAutocomplete() {
  const host = document.querySelector(".search-box");
  const input = document.getElementById("address");
  if (!host || !input) return;

  // Always keep Enter-to-geocode working
  input.addEventListener("keydown", async (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      const q = (input.value || "").trim();
      if (q) {
        say("Searching…");
        await fallbackGeocode(q);
      }
    }
  });

  // Try new Places widget (for new keys)
  try { await google.maps.importLibrary?.("places"); } catch(_) {}
  const hasNew = !!(google?.maps?.places && "PlaceAutocompleteElement" in google.maps.places);
  if (hasNew) {
    try {
      // @ts-ignore
      const pac = new google.maps.places.PlaceAutocompleteElement();
      pac.placeholder = input.placeholder || "Search address...";
      pac.style.width = "100%";
      host.replaceChild(pac, input);

      // @ts-ignore
      pac.addEventListener("gmp-select", async ({ placePrediction }) => {
        const place = placePrediction.toPlace();
        await place.fetchFields({ fields: ["formattedAddress", "location", "viewport"] });
        moveCameraToPlace(place);
        if (API_BASE_URL && place.formattedAddress) tryDrawParcel(place.formattedAddress);
      });

      say("Search ready (new Places).");
      return;
    } catch (e) {
      console.warn("New Places widget failed, falling back:", e);
    }
  }

  // Legacy Autocomplete
  if (google?.maps?.places?.Autocomplete) {
    const ac = new google.maps.places.Autocomplete(input, {
      types: ["address"],
      fields: ["formatted_address", "geometry"],
    });
    ac.addListener("place_changed", async () => {
      const p = ac.getPlace();
      if (!p || !p.geometry) return;
      moveCameraToLegacyPlace(p);
      if (API_BASE_URL && p.formatted_address) tryDrawParcel(p.formatted_address);
    });
    say("Search ready (legacy Places).");
    return;
  }

  // If neither widget is available, Enter-to-geocode still works
  say("Search ready (press Enter to geocode).");
}

function moveCameraToPlace(place) {
  if (place.viewport) map.fitBounds(place.viewport);
  else if (place.location) { map.setCenter(place.location); map.setZoom(18); }
  keepOverhead();
  say("Address found. Outline the lot or measure turf.");
}

function moveCameraToLegacyPlace(p) {
  const loc = p.geometry.location;
  if (p.geometry.viewport) map.fitBounds(p.geometry.viewport);
  else if (loc) { map.setCenter(loc); map.setZoom(18); }
  keepOverhead();
  say("Address found. Outline the lot or measure turf.");
}

async function fallbackGeocode(query) {
  const geocoder = new google.maps.Geocoder();
  return new Promise((resolve) => {
    geocoder.geocode({ address: query }, (results, status) => {
      if (status === "OK" && results[0]) {
        const r = results[0];
        if (r.geometry?.viewport) map.fitBounds(r.geometry.viewport);
        else if (r.geometry?.location) { map.setCenter(r.geometry.location); map.setZoom(18); }
        keepOverhead();
        say("Address found. Outline the lot or measure turf.");
      } else {
        say("Geocode failed — try a full address.");
      }
      resolve();
    });
  });
}

// ---------------- Drawing tools + area updates ----------------
function setupDrawingTools() {
  drawManager = new google.maps.drawing.DrawingManager({
    drawingControl: false,
    polygonOptions: { fillColor: "#22c55e55", strokeColor: "#16a34a", strokeWeight: 2 },
  });
  drawManager.setMap(map);

  byId("btnOutlineLot")?.addEventListener("click", startDrawingLot);
  byId("btnManualTurf")?.addEventListener("click", startDrawingTurf);
  byId("measureBtn")?.addEventListener("click", () => {
    say("Click around the turf area. Double-click to finish.");
    startDrawingTurf();
  });
  byId("btnSearchAgain")?.addEventListener("click", resetAll);
}

function startDrawingLot() {
  drawManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
  google.maps.event.addListenerOnce(drawManager, "polygoncomplete", (poly) => {
    if (lotPolygon) lotPolygon.setMap(null);
    lotPolygon = poly;
    lotPolygon.setOptions({ fillColor: "#00000000", strokeColor: "#ef4444", strokeWeight: 2 });
    drawManager.setDrawingMode(null);
    fitToPolygon(lotPolygon);
    updateAreas();
    say("Lot outlined. Now add turf polygons.");
  });
}

function startDrawingTurf() {
  drawManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
  google.maps.event.addListenerOnce(drawManager, "polygoncomplete", (poly) => {
    poly.setOptions({ fillColor: "#22c55e55", strokeColor: "#16a34a", strokeWeight: 2 });
    turfPolygons.push(poly);
    drawManager.setDrawingMode(null);
    updateAreas();
  });
}

function updateAreas() {
  const areaM2 = (poly) => google.maps.geometry.spherical.computeArea(poly.getPath());
  const lot = lotPolygon ? areaM2(lotPolygon) * 10.7639 : 0;
  const turf = turfPolygons.reduce((s, p) => s + areaM2(p) * 10.7639, 0);
  if (byId("lotSqft")) byId("lotSqft").value = Math.round(lot);
  if (byId("turfSqft")) byId("turfSqft").value = Math.round(turf);
}

function fitToPolygon(poly) {
  const b = new google.maps.LatLngBounds();
  poly.getPath().forEach((p) => b.extend(p));
  map.fitBounds(b);
  keepOverhead();
}

function resetAll() {
  if (lotPolygon) { lotPolygon.setMap(null); lotPolygon = null; }
  while (turfPolygons.length) turfPolygons.pop().setMap(null);
  ["lotSqft","turfSqft","firstName","lastName","phone","email"].forEach((id) => {
    const el = byId(id); if (el) el.value = "";
  });
  say("Type an address and press Enter.");
}

// ---------------- Optional parcel fetch/draw ----------------
async function tryDrawParcel(formattedAddress) {
  if (!API_BASE_URL) { console.warn("Parcel fetch skipped: API_BASE_URL not set"); return; }
  try {
    const url = API_BASE_URL + "/api/parcel-by-address?address=" + encodeURIComponent(formattedAddress);
    const res = await fetch(url);
    if (!res.ok) throw new Error("API " + res.status);
    const data = await res.json();
    const gj = normalizePreciselyToGeoJSON(data);
    const poly = pickFirstPolygon(gj);
    if (poly) drawParcel(poly);
  } catch (e) {
    console.warn("Parcel fetch failed:", e && e.message ? e.message : e);
  }
}

function drawParcel(geometry) {
  if (lotPolygon) { lotPolygon.setMap(null); lotPolygon = null; }
  const ring = extractOuterRing(geometry);
  if (!ring || !ring.length) return;
  const path = ring.map(([lng, lat]) => ({ lat, lng }));
  lotPolygon = new google.maps.Polygon({
    paths: path,
    map,
    strokeColor: "#ef4444",
    strokeWeight: 2,
    fillOpacity: 0,
  });
  fitToPolygon(lotPolygon);
  updateAreas();
  say("Parcel drawn. You can add turf polygons now.");
}

// GeoJSON helpers
function normalizePreciselyToGeoJSON(payload) {
  if (payload?.type === "FeatureCollection" || payload?.type === "Feature") return payload;
  if (Array.isArray(payload?.features)) return { type: "FeatureCollection", features: payload.features };
  if (payload?.geometry?.type && payload?.geometry?.coordinates) {
    return { type: "Feature", geometry: payload.geometry, properties: payload.properties || {} };
  }
  return { type: "FeatureCollection", features: [] };
}
function pickFirstPolygon(gj) {
  const feats = gj?.type === "FeatureCollection" ? gj.features : [gj];
  const f = (feats || []).find((x) => x?.geometry?.type?.includes("Polygon"));
  return f ? f.geometry : null;
}
function extractOuterRing(geometry) {
  if (!geometry || !geometry.coordinates) return null;
  const c = geometry.coordinates;
  if (geometry.type === "MultiPolygon") return c?.[0]?.[0] || null;
  if (geometry.type === "Polygon") return c?.[0] || null;
  if (Array.isArray(c?.[0]) && typeof c[0][0] === "number") return c;
  return null;
}

// Camera & DOM helpers
function keepOverhead(){ if (!map) return; map.setMapTypeId("roadmap"); map.setHeading(0); map.setTilt(0); }
function lockOverhead(){ map.addListener("tilt_changed",()=> map.getTilt()!==0 && map.setTilt(0)); map.addListener("heading_changed",()=> map.getHeading()!==0 && map.setHeading(0)); }
function byId(id){ return document.getElementById(id); }
function say(msg){ const el = byId("mapCaption"); if (el) el.textContent = msg; }
</script>
